Descriviamo ora brevemente le diverse tipologie di cast:

1) static_cast

Probabilmente, è il cast utilizzato più frequentemente. La sintassi

  static_cast<T>(expr)

calcola un nuovo valore ottenuto dalla conversione del valore
dell'espressione expr al tipo T. Il cast è legittimo in uno dei casi
seguenti (elenco parziale, non esaustivo):
 - è legittima la corrispondente conversione implicita (caso banale);
     double d = 3.14;
     int approx = static_cast<int>(d);
 - è legittima la costruzione diretta di un oggetto di tipo T passando
   expr come argomento;
     Razionale r = static_cast<Razionale>(5);
 - si effettua la conversione inversa rispetto ad un sequenza di
   conversione implicita ammissibile (con alcune restrizioni,
   per esempio non si possono invertire le trasformazioni di lvalue);
     int i = 42;
     void* v_ptr = &i;
     int* i_ptr = static_cast<int*>(v_ptr);
 - il cast implementa un downcast in una gerarchia di classi;
 - il cast implementa un cast da un tipo numerico ad un tipo enumerazione;
 - il tipo destinazione è void.

---------------------------------------------------------

2) dynamic_cast

Il dynamic_cast è uno degli operatori che forniscono il supporto per
la cosiddetta RTTI (Run-Time Type Identification, cioè identificazione
del tipo a tempo di esecuzione). I dynamic cast possono essere usati
per effettuare conversioni all'interno di una gerarchia di classi legate
da ereditarietà (singola o multipla). In particolare, si possono effettuare:

 - up-cast: conversione da classe derivata a classe base;
   effettuata raramente mediante dynamic_cast, in quanto è una conversione
   consentita anche implicitamente e quindi non necessita della RTTI.

 - down-cast: conversione da classe base a classe derivata;
   è il caso più frequente di utilizzo del dynamic cast, in quanto si
   sfrutta la RTTI per verificare che la conversione sia legittima.

 - mixed-cast: caso particolare che si verifica quando si utilizza
   l'ereditarietà multipla; consiste in uno spostamento nella gerarchia
   di ereditarietà ottenibile combinando up-cast e down-cast (da cui il
   nome di cast "misto"); siccome prevede comunque la presenza di down-cast,
   anche in questo caso si ha un uso non banale della RTTI.

Il dynamic cast si può applicare ai tipi puntatore (caso tipico) e anche
ai tipi riferimento (caso raro), con una importante differenza semantica.

Supponiamo di avere la seguente gerarchia:

   struct B { /* ... */ };
   struct D1 : public B { /* ... */ };
   struct D2 : public B { /* ... */ };

e di avere la funzione

   void foo(B* b_ptr) { /* ... */ }

Se la classe B è dinamica (ovvero, se contiene almeno un metodo virtuale)
allora è dotata delle informazioni per la RTTI e possiamo applicare cast
dinamici ai puntatori per sapere se sono di un determinato tipo.
Per esempio:

   D1* d1_ptr = dynamic_cast<D1*>(b_ptr)

Dopo l'esecuzione di questo cast, se il puntatore b_ptr punta ad un oggetto
di tipo D1 (incluso eventualmente un oggetto di una classe derivata, anche
indirettamente, da D1), allora d1_ptr avrà assegnato un valore NON nullo;
se invece b_ptr non punta ad un oggetto di tipo D1 (per esempio, punta
ad un oggetto di tipo D2), allora a d1_ptr viene assegnato il puntatore
nullo. Di conseguenza, il programmatore può sapere se il cast è andato
a buon fine controllando se il puntatore è non nullo:

  if (d1_ptr != nullptr) {
    /* d1_ptr è valido */
  }

  if (d1_ptr) {
    /* equivalente: ho sfruttato la conversione a bool */
  }

  if (D1* d1_ptr = dynamic_cast<D1*>(b_ptr)) {
    /* equivalente: ho compattato cast e test */
  }

Il caso di conversione per un riferimento è diverso (e raro), perché
non esiste il concetto di riferimento nullo e quindi NON possiamo
usare facilmente cast dinamici su riferimento per fare dei test RTTI.
Se proviamo ad eseguire questo:

   D1& d1_ref = dynamic_cast<D1&>(*b_ptr)

se b_ptr punta ad un D1, il cast va a buon fine e d1_ref è inizializzato
correttamente; se invece NON punta a D1, il cast dinamico fallisce e,
non potendo segnalare la cosa con il riferiemento nullo, genera una
eccezione (di tipo std::bad_cast).

---------------------------------------------------------

3) const_cast

Il const_cast viene usato per rimuovere la qualificazione const.
Tipicamente, si applica ad un riferimento o puntatore ad un oggetto
qualificato const (cioè non modificabile) per ottenere un riferimento o
puntatore ad un oggetto non qualificato (e quindi modificabile).
----
void promessa_da_marinaio(const int& ci) {
  int& i = const_cast<int&>(ci);
  ++i;
}
La funzione ha promesso al chiamante che NON modificherà l'argomento,
ma si rimangia la promessa, elimina la qualificazione const e poi
modifica l'argomento (proprio quello passato dal chiamante, non una copia).
----

Usando il const_cast, quindi, potremmo "rompere" il contratto stipulato
con l'utente. Tra i pochi casi in cui può essere legittimo usare questo
tipo di cast possiamo elencare i metodi di una classe che devono modificare
la rappresentazione interna di un oggetto, senza però alterarne davvero
il significato. Si tratta quindi di metodi che mantengono la "constness"
a livello logico, pur violandola a livello fisico.

Esempio:
Una classe mantiene un collezione di elementi ed è fornita di un metodo
(etichettato const) che stampa gli elementi secondo un dato ordinamento.
L'ordinamento è costoso da calcolare e quindi la collezione è mantenuta
internamente NON ordinata. Quando però mi viene richiesta una stampa
ordinata, potrei decidere di modificare la rappresentazione interna
allo scopo di memorizzare la sequenza ordinata (di modo che successive
chiamate della routine di stampa siano più efficienti). In questo caso,
la routine di stampa potrebbe usare un const_cast per modificare la
rappresentazione interna (senza però modificare dal punto di vista semantico
la collezione).

Nota: alcuni usi di const_cast si potrebbero eliminare mediante l'utilizzo
del modificatore mutable su alcuni dati membro di una classe.

---------------------------------------------------------

4) reinterpret_cast

Un reinterpret cast può essere usato per effettuare le seguenti conversioni:
  - da un tipo puntatore ad un tipo intero (sufficientemente grande da
    poter rappresentare il valore del puntatore);
  - da un tipo intero/enumerazione ad un tipo puntatore;
  - da un tipo puntatore (oppure riferimento) ad un altro tipo puntatore
    (oppure riferimento).

Nota: non è possibile usare un reinterpret_cast per rimuovere la
qualificazione const (occorre usare il const_cast).

Nota: nel caso del reinterpret_cast (diversamente dallo static_cast) le
conversioni tra puntatori sono consentite anche quando i due tipi
puntati NON sono in alcuna relazione tra di loro (in particolare, anche
quando non fanno parte di una gerarchia di classi derivate).
Quindi i reinterpret_cast sono una tra le forme di conversione più
pericolose, in quanto i controlli di correttezza sono lasciati quasi
completamente nelle mani del programmatore.

---------------------------------------------------------

5) cast funzionale

La sintassi T(expr) oppure T(), dove T è il nome di un tipo, viene
spesso indicata come "cast funzionale"; intuitivamente, corrisponde alla
costruzione diretta di un oggetto di tipo T, usando un costruttore
(nel secondo caso, il costruttore di default).
Si parla di cast funzionale in quanto la sintassi si può applicare
anche al caso dei tipi builtin (che in senso tecnico non sono dotati
di costruttori). Nel caso di un tipo builtin, la forma T() produce
la cosiddetta zero-initialization.

Esempio:
template <typename T, typename U>
void foo(T t, U u) {
  if (t == T(u)) // cast funzionale
    // ...
}
Se foo viene istanziata con T = int e U = double,
il test condizionale diventa
  if (t == int(u))
nel quale abbiamo il cast funzionale int(u).

---------------------------------------------------------

6) cast stile C

Hanno la sintassi

  (T) expr

Il loro uso è considerato cattivo stile (tranne il caso nominato sopra
del cast a void per sopprimere warning del compilatore), perché:
  - sono difficili da individuare nel codice mediante ricerca testuale;
  - non differenziano le diverse tipologie di cast.

Con i cast stile C si possono simulare static_cast, const_cast e
reinterpret_cast, ma NON si possono effettuare i dynamic_cast
(in particolare, non hanno accesso a informazioni RTTI e quindi
non effettuano nessun controllo a run-time).

---------------------------------------------------------
