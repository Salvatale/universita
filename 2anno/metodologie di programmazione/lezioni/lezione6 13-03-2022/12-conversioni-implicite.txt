
-- Conversioni implicite di tipo

Si ricorda che le conversioni di tipo implicite sono uno dei concetti
oggetto di ripasso che si danno per acquisiti. Nel seguito, quindi,
si richiamano brevemente le varie tipologie di conversione, con lo
scopo di classificarle (questa operazione è necessaria soprattutto
per potere effettuare la fase 3 della risoluzione dell'overloading).

Le conversioni implicite del C++ si possono suddividere in
4 categorie (Nota: le categorie sarebbero 5, ma per semplicità
NON prendiamo in considerazione le conversioni che si applicano
nel caso della sintassi "...", ereditata dal C, che consente di
avere un numero arbitrario di parametri per una funzione).

1) Le corrispondenze "esatte"

Le corrispondenze esatte corrispondono ad alcune conversioni implicite
di tipo che sono garantite preservare il valore dell'argomento
(nota: vi sono comunque conversioni che, pur preservando il valore,
non fanno parte delle corrispondenze esatte).
Non c'è nessuna perdita di informazione vera e propria, ci sono altre conversioni
che non fanno perdere informazioni ma non sono classificate esatte.
Le corrispondenze esatte si possono suddividere nelle seguenti sottoclassi:

  1a) identità (match perfetti)
      In realtà, questa NON è una conversione, perché tipo di partenza
      e tipo di destinazione coincidono; è comunque comodo includerla
      come caso speciale nella classificazione, per poter ragionare
      in modo più semplice durante la risoluzione dell'overloading.
      Es: (si assumono le dichiarazioni "int i; const int& r = i;")
      tipo parametro    argomento
         int               5		è esattamente un'identità dato che riceve effettivamente un valore intero
         int&              i		mi aspetto di ricevere un riferimento a qualcosa che può contenere un tipo
					intero e posso modificarlo, il chiamante passa i che è una variabile di tipo
					intero modificabile e quindi match perfetto.
         int*              &i		Il chiamato dichiara un puntatore di intero modificabile e il chiamante 
					passa l'indirizzo della variabile tipo intero.
         const int&        r		Il chiamato vuole un riferimento ad un intero costante ed il chiamante
					invia una variabile intera di tipo costante.
         double            5.2
	 double		   5.2f questo non è un match invece.	

  1b) trasformazioni di lvalue
      Es: (si assumono le dichiarazioni "int a[10];" e "void foo();")
        tipo parametro    argomento
         int              i         (da lvalue a rvalue)
         int*             a         (decay array-puntatore)
         void(*)()        foo       (decay funzione-puntatore)
	
	Il primo caso non è un match perfetto, i è un l-value, la chiamata è interessata al valore
	contenuto dentro quel l-value e non all'l-value e quindi si prende la variabile i e si pesca
	il valore contenuto dentro l' lvalue, fai una copia ed utilizzata per inizializzare il mio
	parametro per valore.
	
	Il secondo esempio, si passa un'array che decade a puntatore del primo elemento dell'array, è
	un'altra trasformazione lvalue, a è un'array di 100 interi e passato alla funzione si ottiene
	un puntatore di intero e c'è il decadimento di tipo perchè si sa solo che è un'indirizzo di un elemento
	di tipo intero e spetta al programmatore sapere che era un array di 100 interi, quindi il tipo perde
	informazioni ma non il valore.
	
	Il terzo caso si passa l'indirizzo ad una funzione che può chiamare.
	void*() è diverso dato che è il tipo di una funzione che non prende niente restituisce un puntatore
	a void, mentre nel nostro caso è il puntatore alla funzione che poi restituisce void.
	
  1c) conversioni di qualificazione
      (viene aggiunto il qualificatore const)
      Es:
        tipo parametro    argomento
          const int&         i
          const int*         &i

2) Le promozioni

Deriva dal C.
Le promozioni corrispondono ad alcune conversioni implicite
di tipo che, come le conversioni esatte, sono garantite preservare
il valore dell'argomento.
Il tipo int è i tipo intero che può essere rappresentato in modo più efficente
sulla mia architettura, se ho il computer a 32 bit allora int sarà a 32 bit.
Su alcune architetture non esiste il concetto di sommare due byte e possono 
lavorare solo sui registri che sono di 32 bit non di 1 byte, tutte le volte
che si vogliono fare dei calcoli con interi piccoli, essi vengono promossi.
Ogni implementazione del linguaggio C++ è specifica per una particolare
architettura del processore (per esempio, con "parole" di 16, 32 o 64 bit).
Tradizionalmente, i tipi int e unsigned int vengono forniti della
dimensione adeguata per ottenere la massima efficienza su quella
particolare architettura. Al contrario, i tipi interi più piccoli
di int non sono direttamente rappresentabili all'interno del processore
(per esempio, il processore sa effettuare la somma di due registri
o farne il confronto, ma tipicamente non è dotato di istruzioni che
effettuano la somma o effettuano il confronto tra porzioni di registri).
Quindi, ogni volta che si vuole operare su un valore di un tipo di dato
più piccolo di "int", questo deve essere "promosso" al tipo int
(o unsigned int) per potere effettuare l'operazione.
Si crea potenzialmente un tipo più grande ma non si perdono informazioni.

  2a) promozioni intere:
    * dai tipi interi piccoli (char/short, signed o unsigned)
      al tipo int (signed o unsigned);
    * da bool a int è promozione (caso speciale)
Se abbiamo unsigned short che è di 16 bit e un signed short che è di 32 bit
allora la promozione da unsigned short avviene verso signed short, se invece
unsigned short è di 32 bit allora potrebbe non starci dentro l'intero signed di 32 bit
quindi la promozione avviene verso unsigned int.
In ogni caso il tipo di arrivo è int o unsigned int.

  2b) promozioni floating point:
    * da float a double

  2c) promozione delle costanti di enumerazioni del C++ 2003
      al più piccolo tipo intero (almeno int) sufficientemente
      grande per contenerle
enum:char si stabilisce il tipo da utilizzare per le costanti di enumerazioni,
Per le costanti di enumerazioni che non utilizzano questo meccanisco dove si utilizza 
un intero o qualcosa di più grande che può contenere qualsiasi tipo di valore

3) conversioni standard:
   in pratica, tutte le altre conversioni implicite che non
   coinvolgono conversioni definite dall'utente

   Attenzione:
     da int a long non è promozione, ma conversione standard
     da char a double: è conversione standard
     ... eccetera.

   Tra le conversioni standard da tenere in considerazione vi sono
   le conversioni tra riferimenti e tra puntatori.
   In particolare:
     - la costante intera 0 e il valore nullptr (di std::nullptr_t)
       sono le costanti puntatore nullo; esse possono essere convertite
       implicitamente nel tipo T* (per qualunque T);
       la costante intera 0 può essere convertita in nullptr;
     - ogni puntatore T* può essere convertito nel tipo void*,
       che corrisponde ad un puntatore ad un tipo ignoto
       (si noti che non esiste una conversione implicita che vada
       in senso inverso, da void* a T*);
     - se un classe D è derivata (direttamente o indirettamente)
       dalla classe base B, allora ogni puntatore D* può essere
       convertito implicitamente in B*; si parla di "up-cast"
       (conversione verso l'alto), perché tradizionalmente nei
       diagrammi che rappresentano le relazioni tra i tipi di dato,
       le classi base, che sono più astratte e quindi "leggere",
       vengono rappresentate sopra le classi derivate, che sono
       più concrete e quindi "pesanti"; una analoga conversione
       sui riferimenti consente di trasformare un D& in un B&;
       (anche in questo caso, si noti che non esiste una conversione
       implicita per il "down-cast", che trasformerebbe un B* in un D*
       o un B& in un D&).

4) conversioni implicite definite dall'utente
  4a) uso (implicito) di costruttori che possono essere invocati
      con un solo argomento (di tipo diverso) e non sono marcati `explicit'
      Esempio:
      struct Razionale {
        Razionale(int num, int den = 1); // conv. da int a Razionale
        // ...
      };
Il costruttore explicit Razionale(int num, int den = 1); l'explicit fà si che il programmatore
possa utilizzare questo tipo di costruttore esplicitamente e non avere una conversione implicita
come nel nostro esempio.


  4b) uso di operatori di conversione da tipo utente verso altro tipo
      Esempio:
      struct Razionale {
        operator double() const; // conversione da Razionale a double
        // ...
      };
Anche in questo caso si potrebbe avere explicit.
	
	foo(Razionale r);
	foo(5); questa funzione sarebbe utilizzabile senza l'explicit dato che fa una conversione implicita.
	
	foo(Razionale(5)); con l'explicit per ottenere lo stesso risultato si dovrebbe fare una chiamata così.
	
------------------------------------------------------------------------
