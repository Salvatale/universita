
*** Alcune questioni tecniche sul polimorfismo dinamico

Abbiamo visto che, nel caso di polimorfismo dinamico, le classi astratte
sono tipicamente formate da metodi virtuali puri, più il distruttore della
classe che è dichiarato virtuale, ma non puro. In alcuni casi è però
necessario complicare il progetto (ad esempio, usando l'ereditarietà
multipla): quando lo si fa, si corre il rischio di incorrere in errori
ed è quindi opportuno cercare le risposte ad alcune domande tecniche
sul polimorfismo dinamico, che possono diventare rilevanti quando viene
utilizzato al di fuori dei confini stabiliti nei nostri semplici esempi.

-----------------------------------------------------------------------

1) ci sono metodi che NON possono essere dichiarati virtuali?

In particolare, cosa si può dire sulla possibilità o meno di rendere
virtuali le seguenti categorie di metodi:
  - costruttori
  - distruttori
  - funzioni membro (di istanza, cioè non statiche)
  - funzioni membro statiche
  - template di funzioni membro (non statiche)
  - funzioni membro (non statiche) di classi templatiche

-----------------------------------------------------------------------

2) Come faccio a costruire una copia di un oggetto concreto quando
   questo mi viene fornito come puntatore/riferimento alla classe base?
   
   class Animale {
   	// "costruttori virtuali"
   	virtual Animale* clone() const = 0;
   	
   	virtual Animale* clone_strana(Cane* pc) const = 0;
   }
   
   class Cane : public Animale {
   	//"costruttori virtuali"
   	Cane* clone() const override {
   		return new Cane(*this);
   	}
   };
   
   //Utente amante dei cani e solo dei cani
   
   void foo(const Cane* pc) {
   	//crea una copia
   	Animale* pa2 = pc->clone();
   	Cane* pc2 = pc->clone();
   } 	

-----------------------------------------------------------------------

3) Cosa succede se si invoca un metodo virtuale durante la fase di
   costruzione o di distruzione di un oggetto?
   
   Secondo lo standard del 98 si finiva in undefined behaviour, le guidelinea
   dicevano di non invocare un metodo virtuale durante la costruzione, negli standard nuovi
   si finisce in define behaviour.

-----------------------------------------------------------------------

4) Come funziona l'ereditarietà multipla quando NON ci si limita
   al caso delle interfacce astratte?

   - scope e ambiguità
   - classi base ripetute
   - classi base virtuali
   - semantica speciale di inizializzazione

-----------------------------------------------------------------------

5) Quali sono gli usi del polimorfismo dinamico nella libreria standard?

   - classi eccezione standard
   - classi iostream
  
   
